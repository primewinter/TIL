## 1장 JPA 소개

### 1.1 SQL을 직접 다룰 때의 문제점

다음과 같이 SQL을 직접 다루는 코드를 짰다고 해보자.

- **회원 객체(엔티티)**

```java
public class Member {
	private String id;
	private String name;
}
```

- **회원용 DAO**

```java
public class MemberDAO {
	public Member find(String id) {...}
}
```

- **SQL**

```xml
SELECT ID, NAME FROM MEMBER M WHERE ID = ?
```

- **JDBC API**

```java
ResultSet rs = stmt.executeQuery(sql);
```

- **조회 결과 객체에 매핑**

```java
String id = rs.getString("ID");
String name = rs.getString("NAME");

Member member = new Member();
member.setId(id);
member.setName(name);
```

이런 상황에서

1. 등록 기능을 추가한다면
    
 1) INSERT SQL 작성 2) DAO 수정 3) 객체의 값을 꺼내서 등록 SQL에 전달 4) JDBC API로 SQL 실행
    
2.  객체에 속성이 추가된다면
    
 1) 회원 객체 필드 추가 2) 기존 INSERT, SELECT SQL 수정 3) 결과값 매핑 코드 수정
    

변경이 있을 때마다 엔티티, SQL, 매핑 등 모든 코드를 수정을 해야 한다. 즉, 계층 분할이 제대로 되어 있다고 보기 어렵다. 또한, 실제 DB에 있는 컬럼이 엔티티 객체에는 추가되어 있지 않을 수도 있다는 점에서 엔티티를 신뢰할 수 없다. 결과적으로 SQL에 매우 의존적인 개발을 피할 수 없는 것이다.

**JPA는 이러한 문제를 어떻게 해결할까?**

JPA는 SQL을 작성하는 API를 제공하기 때문에 개발자가 직접 SQL을 작성하지 않아도 알아서 적절한 SQL을 생성하여 데이터베이스에 전달한다. CRUD API로 다음과 같은 것들이 있다.

```java
jpa.persist(member); // 저장
jpa.find(Member.class, id); // 조회

Member member = jpa.find(Member.class, id);
member.setName("이름변경"); // 수정 : 별도의 수정 메소드는 없지만 객체를 조회해서 값을 변경만 하면 트랜잭션을 커밋할 때 적절한 UPDATE SQL이 전달된다.

Member member = jpa.find(Member.class, id);
Team team = member.getTeam(); // 연관된 객체 조회 : 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다
```

### 1.2 패러다임의 불일치

*애플리케이션을 개발하는 일은 끊임없이 증가하는 복잡성과의 싸움이다.* 객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등의 특징을 가진다. 비즈니스 요구사항을 정의한 도메인 모델을 객체로 모델링하면 객체지향 언어의 특징을 활용할 수 있다. 도메인 객체가 다른 객체를 참조하거나, 상속하는 경우 객체의 상태를 저장하기는 쉽지 않다. 연관 객체도 동시에 저장해야 하기 때문이다. 결과적으로 객체들을 RDBMS에 저장하게 되는데, 여기서 ***패러다임의 불일치***가 발생한다.

RDBMS는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 그리고 객체지향에서 이야기하는 추상화, 상속, 다형성 같은 개념이 없다. 객체와 RDBMS는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다. 따라서 객체 구조를 테이블 구조에 저장하는 데에는 한계가 있다.

애플리케이션은 자바라는 객체지향 언어로 개발하고 데이터는 관계형 데이터베이스에 저장해야 한다면, 패러다임의 불일치 문제를 개발자가 중간에서 해결해야 한다. 그 과정에서 너무 많은 시간과 코드를 소비한다. 점점 객체 모델링은 힘을 잃고 데이터 중심의 모델로 변해간다.

**JPA는 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다.**

- **상속**
    
    ITEM을 상속하는 ALBUM과 MOVIE를 저장하려면 ITEM 저장 후 ALBUM 저장, ITEM 저장 후 MOVIE 저장 이렇게 객체를 분해해서 두 개의 SQL을 만들어야 한다. 조회하기 위해서는 테이블을 조인해서 조회한 후 그 결과로 자식 객체를 생성해야 한다.
    **JPA의 경우** persist() 메소드를 이용해 ALBUM을 저장하면 알아서 ITEM과 ALBUM 두 테이블에 나누어 저장한다. 조회 역시 알아서 해준다.
    
- **연관관계**
    
    *객체*는 참조를 통해 다른 객체와 연관관계를 가지고 참조에 접근해서 연관 객체를 조회한다. 반면에 *테이블*은 외래키를 사용하여 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다. 
    **JPA의 경우** 연관관계를 setXXX()를 통해 설정하고 persist()를 통해 저장하면 연관관계가 함께 저장된다. 
    
- **객체 그래프 탐색**
    
    SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.
    
    JPA의 경우 연관된 객체를 신뢰하고 마음껏 조회할 수 있다. 실제 객체를 사용하는 시점까지 DB 조회를 미룬다고 해서 **지연 로딩**이라고 한다.
    
- **비교하기**
    
    DB는 기본 키의 값으로 각 row를 구분한다. ↔ 객체는 동일성identity 비교와 동등성equality 비교라는 두 가지 비교 방법이 있다.
    
    - 동일성 비교 : == 비교. 객체 인스턴스의 주소 값 비교
    - 동등성 비교 : equals() 메소드로 객체 내부의 값을 비교
    
    JPA의 경우 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.
    

### 1.3 JPA란 무엇인가?

JPA(Java Persistence API)는 ***자바 진영에서 힘을 모아서 만든 ORM 기술 표준***이다. 그렇다면 ***ORM(Object-Relational Mapping)이란*** 무엇일까? ORM은 객체와 RDBMS를 매핑한다는 뜻으로, ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다. 

![https://user-images.githubusercontent.com/57691894/139679314-813136ac-efa3-4a4f-9416-c267b0fe091c.png](https://user-images.githubusercontent.com/57691894/139679314-813136ac-efa3-4a4f-9416-c267b0fe091c.png)

![https://user-images.githubusercontent.com/57691894/139679311-99fcaebd-8366-42b0-af68-aa0e59bec265.png](https://user-images.githubusercontent.com/57691894/139679311-99fcaebd-8366-42b0-af68-aa0e59bec265.png)

- **생산성 증진**
    
    JPA에게 저장할 객체를 전달만 하여 반복적인 CRUD SQL 작성에서 벗어날 수 있다. 이는 곧 DB 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.
    
- **유지보수 용이**
    
    직접 작성해야 했던 SQL과 JDBC API 코드를 JPA가 대신 처리하여 유지보수해야 하는 코드 범위가 줄어든다.
    
- **패러다임의 불일치 해결**
    
    JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결해준다.
    
- **성능 최적화**
    
    JPA는 애플리케이션과 DB 사이에서 동작하기 때문에, 두 번 SQL 날릴 것을 한 번만 SELECT하여 해당 객체를 재사용하는 등 최적화 관점에서 시도해 볼 수 있는 것들이 있다.
    
- **데이터 접근 추상화와 벤더 독립성**
    
    예를 들어 DB마다 페이징 처리 방법이 달라서 사용법을 각각 배워야 한다. JPA는 애플리케이션과 DB 사이에 추상화된 데이터 접근 계층을 제공해서 특정 DB 기술에 종속되지 않도록 한다.
    
- **표준**
    
    표준을 사용하면 다른 구현 기술로 손휩게 변경할 수 있다.
