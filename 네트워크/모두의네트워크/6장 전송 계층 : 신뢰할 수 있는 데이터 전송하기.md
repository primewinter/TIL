# 23 전송 계층의 역할

물리 계층, 데이터 링크 계층, 네트워크 계층의 3계층이 있으면 목적지에 데이터를 보낼 수 있지만 데이터가 손상되거나 유실되더라도 이 계층들에서는 아무것도 해주지 않는다. **전송 계층**은 **목적지에 신뢰할 수 있는 데이터를 전달**하기 위해 필요하다.

### 전송 계층 기능

전송 계층에는 **오류를 점검하는 기능**이 있어서 오류가 발생하면 데이터를 재전송하도록 요청한다. 또한 **전송된 데이터의 목적지가 어떤 애플리케이션인지 식별**하는 기능이 있다.

### 특징

- **신뢰성/정확성 :** 데이터를 목적지에 문제없이 전달하는 것
- **효율성 :** 데이터를 빠르고 효율적으로 전달하는 것

- **연결형 통신**

    신뢰할 수 있고 정확하게 데이터를 전송

    통신 프로토콜로 **TCP**가 사용된다.

- **비연결형 통신**

    신뢰성을 보장하진 않지만 효율적으로 빨리 데이터를 전송 ex) 동영상

    통신 프로토콜로 **UDP**가 사용된다.

# 24 TCP의 구조

TCP는 연결형 통신에 사용되는 프로토콜이다.

### TCP 헤더

![https://user-images.githubusercontent.com/57691894/130984576-064d367c-f877-45c4-a16c-95b70387bea5.png](https://user-images.githubusercontent.com/57691894/130984576-064d367c-f877-45c4-a16c-95b70387bea5.png)

### 연결(connection)

TCP 통신에서 정보를 전달하기 위해 사용되는 **가상의 독점 통신로**로 연결을 확립하고 데이터를 전송한다.

**코드비트**

코드비트에는 연결의 제어 정보가 기록된다. 각 비트별로 역할이 있다. 초기값은 0이고, 비트가 활성화되면 1이 된다. 연결을 확림하려면 SYN과 ACK가 필요하다.

- **SYN : 연결요청**
- **ACK : 확인응답**

|URG|ACK|PSH|RST|SYN|FIN|
|---|---|---|---|---|---|
|0|0|0|0|0|0|

### 3-way 핸드셰이크

신뢰할 수 있는 연결을 하려면 데이터를 전송하기 전에 패킷을 교환하는데, 세 번 확인한다.

1. **연결 확립 요청** : 컴퓨터B의 허가를 받기 위해 컴퓨터A에서 컴퓨터B로 **SYN**을 보낸다.

    |URG|ACK|PSH|RST|***SYN***|FIN|
    |---|---|---|---|---|---|
    |0|0|0|0|***1***|0|

2. **연결 확립 응답 + 연결 확립 요청** : 컴퓨터B는 요청을 허가한다는 응답을 회신하기 위해 **ACK**를 보낸다. 동시에 컴퓨터B도 컴퓨터A에게 데이터 전송 허가를 받기 위해 **SYN**을 보낸다.

    |URG|***ACK***|PSH|RST|***SYN***|FIN|
    |---|---|---|---|---|---|
    |0|***1***|0|0|***1***|0|

3. **연결 확립 응답** : 컴퓨터B의 요청을 받은 컴퓨터A는 허가한다는 응답으로 **ACK**을 보낸다.

    |URG|***ACK***|PSH|RST|SYN|FIN|
    |---|---|---|---|---|---|
    |0|***1***|0|0|0|0|

데이터를 전송한 후에는 연결을 끊기 위한 요청을 교환해야 한다. 이때 FIN과 ACK를 사용한다.

- **FIN : 연결 종료**
1. 연결 종료 요청 : 컴퓨터A에서 컴퓨터B로 FIN을 보낸다.

    |URG|ACK|PSH|RST|SYN|***FIN***|
    |---|---|---|---|---|---|
    |0|0|0|0|0|***1***|

2. 연결 종료 응답 : 컴퓨터B에서 컴퓨터A로 ACK를 반환한다.

    |URG|***ACK***|PSH|RST|SYN|FIN|
    |---|---|---|---|---|---|
    |0|***1***|0|0|0|0|

3. 연결 종료 요청 : 컴퓨터B에서 컴퓨터A로 FIN을 보낸다.

    |URG|ACK|PSH|RST|SYN|***FIN***|
    |---|---|---|---|---|---|
    |0|0|0|0|0|***1***|

4. 연결 종료 응답 : 컴퓨터A에서 컴퓨터B로 ACK를 반환한다.

    |URG|***ACK***|PSH|RST|SYN|FIN|
    |---|---|---|---|---|---|
    |0|***1***|0|0|0|0|

# 25 일련번호와 확인 응답 번호의 구조

3-way 핸드셰이크가 끝나고 실제 데이터를 보내거나 상대방이 받을 때는 TCP 헤더의 일련번호와 확인 응답 번호를 사용한다.

![https://user-images.githubusercontent.com/57691894/131220380-d9334a14-76fe-4379-bb98-69509b4e7bf1.png](https://user-images.githubusercontent.com/57691894/131220380-d9334a14-76fe-4379-bb98-69509b4e7bf1.png)

### 3) 일련번호

TCP를 데이터를 분할해서 보내는데 일련번호는 송신 측에서 수신 측에 **'이 데이터가 몇 번째 데이터인지' 알려 주는 역할**을 한다.

### 4) 확인 응답 번호

수신 측이 **몇 번째 데이터를 수신했는지 송신 측에 알려주는 역할**을 한다. 확인 응답 번호는 다음 번호의 데이터를 요청하는 데에도 사용된다. 가령 3번 데이터를 수신하면 4번 데이터를 송신 측에 요청하는 것이다. 이를 **확인 응답**이라고 한다.

1. 컴퓨터A에서 컴퓨터B로 200바이트의 데이터를 전송한다.

    |A|일련번호|확인 응답 번호|B|
    |:---:|:---:|:---:|:---:|
    |→|3001|4001|→|

2. 컴퓨터B는 200바이트를 수신하고 다음에 수신하고자 하는 데이터 번호를 확인 응답 번호에 넣는다. 다음에 수신하고자 하는 데이터는 3001 + 200 = 3201 이므로 3201번부터 보내 달라고 요청한다.

    |A|일련번호|확인 응답 번호|B|
    |:---:|:---:|:---:|:---:|
    |←|4001|3201|←|

3. 컴퓨터A는 컴퓨터B로 3201번부터 200바이트의 데이터를 전송한다.

    |A|일련번호|확인 응답 번호|B|
    |:---:|:---:|:---:|:---:|
    |→|3201|4001|→|

4. 컴퓨터B는 200바이트를 수신하고 다음에 수신하고자 하는 데이터의 번호를 확인 응답 번호에 넣는다. 다음에 수신하고자 하는 데이터는 3201 + 200 = 3401 이므로 3401번부터 보내 달라고 요청한다.

    |A|일련번호|확인 응답 번호|B|
    |:---:|:---:|:---:|:---:|
    |←|4001|3401|←|

- 데이터가 항상 올바르게 전달되는 것은 아니므로 일련번호와 확인 응답 번호를 사용해서 데이터가 손상되거나 유실된 경우에 데이터를 재전송하게 되어 있다. 이를 **재전송 제어**라고 한다.

### 8) 윈도우 크기

세그먼트(데이터) 하나 보낼 때마다 확인 응답을 한 번 반환하는 통신은 효율이 낮다. 세그먼트를 연속적으로 보내 **버퍼(buffer)**에 보관했다가 한 번에 확인 응답을 반환하면 효율을 높일 수 있다. 수신 측에서 버퍼의 한계 이상으로 데이터를 받아 버리면 **오버플로(overflow)**가 발생한다.

윈도우 크기는 이 **버퍼의 한계 크기**를 의미한다. 즉 얼마나 많은 용량의 데이터를 저장해 둘 수 있는지를 나타낸다.

윈도우 크기의 초기값은 3-way 핸드셰이크를 할 때 판단한다.

**3-way 핸드셰이크**

1. **연결 확립 요청**

    |일련번호|확인 응답 번호|윈도우 크기|
    |:---:|:---:|:---:|
    |||3000(컴퓨터A의 윈도우 크기)|

    |URG|ACK|PSH|RST|***SYN***|FIN|
    |---|---|---|---|---|---|
    |0|0|0|0|***1***|0|

2. **연결 확립 응답 + 연결 확립 요청**

    |일련번호|확인 응답 번호|윈도우 크기|
    |:---:|:---:|:---:|
    |||2000(컴퓨터B의 윈도우 크기)|

    |URG|***ACK***|PSH|RST|***SYN***|FIN|
    |---|---|---|---|---|---|
    |0|***1***|0|0|***1***|0|

3. **연결 확립 응답**

    |URG|***ACK***|PSH|RST|SYN|FIN|
    |---|---|---|---|---|---|
    |0|***1***|0|0|0|0|

이 과정에서 서로의 윈도우 크기를 확인한다. 그 후로는 세그먼트(데이터)를 연속해서 보내고, 확인 응답을 연속해서 받을 수 있다.

# 26 포트 번호의 구조

전송 계층은 1) 데이터를 정확하게 전달하는 역할과 2) 전송된 데이터의 목적지가 어떤 애플리케이션인지 구분하는 역할을 한다. 지금까지 1)의 기능을 알아보았고, 이제는 2)의 기능을 알아보도록 한다.

![https://user-images.githubusercontent.com/57691894/131251794-17eaa0fc-9dc2-47bc-8f23-2249eab421fd.png](https://user-images.githubusercontent.com/57691894/131251794-17eaa0fc-9dc2-47bc-8f23-2249eab421fd.png)

TCP 헤더의 **출발지 포트 번호**와 **목적지 포트 번호**를 통해 **목적지가 어떤 애플리케이션인지 구분**할 수 있다. 포트 번호는 0~65535번을 사용할 수 있다.

- **0~1023번 포트** : 주요 프로토콜이 사용하도록 예약되어 있다. 이러한 포트를 **잘 알려진 포트(well-known port)**라고 한다. 일반적으로 사용하는 서버 측 애플리케이션에서 사용된다.

    |애플리케이션|포트 번호|
    |:---:|:---:|
    |SSH|22|
    |SMTP|25|
    |DNS|53|
    |HTTP|80|
    |POP3|110|
    |HTTPS|443|

- 1024번 포트 : 예약되어 있지만 사용되지는 않는 포트
- **1025번 이상 포트** : 랜덤 포트라고 해서 클라이언트 측의 송신 포트로 사용한다. 웹 브라우저로 접속할 때 웹 브라우저에는 임의의 포트가 자동으로 할당된다. 서버 측에서는 포트 번호를 정해 두어야 하지만 클라이언트 측은 정하지 않아도 된다.

# 27 UDP의 구조

### TCP의 역할

TCP의 역할은 한마디로 신뢰할 수 있는 데이터를 상대방에게 전달하는 것이다. 풀어서 말하자면, 3-way 핸드셰이크로 연결이 확립된 후에 데이터를 전송하고 그때 확인 응답을 한다. 데이터 전송 도중에 오류가 발생하면 재전송하거나 포트 번호로 애플리케이션을 구분하여 데이터를 정확하게 전달한다.

### UDP의 역할

TCP와 달리 UDP는 비연결형 통신이라서 데이터를 전송할 때 시간이 걸리는 확인 작업을 일일이 하지 않는다. UDP의 장점은 데이터를 효율적으로 빠르게 보내는 것이라서 스트리밍 방식으로 전송하는 동영상 서비스와 같은 곳에서 사용된다.

### UDP 헤더

![https://user-images.githubusercontent.com/57691894/131252625-84767e2d-6a25-4edd-a94e-2055c9c6368d.png](https://user-images.githubusercontent.com/57691894/131252625-84767e2d-6a25-4edd-a94e-2055c9c6368d.png)

UDP 헤더가 붙은 데이터를 UDP 데이터그램이라고 한다.

![https://user-images.githubusercontent.com/57691894/131252932-2cc19358-80d8-4494-9f45-48ccf7b2ea5c.png](https://user-images.githubusercontent.com/57691894/131252932-2cc19358-80d8-4494-9f45-48ccf7b2ea5c.png)

### 브로드캐스트

UDP를 사용하면 랜에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄로 보낼 수 있다. UDP에서의 브로드캐스트는 목적지에 관계없이 랜에서 일괄적으로 보내지만, TCP는 목적지를 지정하지 않으면 안 되기 때문에 일괄 통신을 하기 힘들다. 

+) TCP는 3-way 핸드셰이크와 같이 데이터를 전송할 때도 확인 응답을 하나씩 보내야 하기 때문에 브로드캐스트와 같이 불특정 다수에게 보내는 통신에는 적합하지 않다.
